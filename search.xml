<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[在js中正确获取元素的样式值]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%9C%A8js%E4%B8%AD%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%80%BC%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在日常的界面制作中，常常需要在js中动态操作元素的样式。一般会使用到obj.style.width之类的获取，但是有时能够获取到样式值，有时不能。在这文章中，主要解释一下这种现象出现的原因和解决方法。 样式种类css的样式主要分为三种： 内联样式: 也称为行内样式，直接写在DOM元素的style属性内； 内嵌样式：写在HTML的&lt;/style&gt;&lt;style&gt;中的样式 外部样式：由link标签引入的css文件中的样式 以上样式的优先级：内联&gt;内嵌&gt;外部 首先，来测试一下这三种样式使用obj.style.width格式的样式值获取情况：12345678910111213141516&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;get style&lt;/title&gt; &lt;style&gt; &lt;!-- 嵌入样式 --&gt; .box &#123; height: 200px; &#125; &lt;/style&gt; &lt;!-- 引入外部样式 --&gt; &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 行内样式 --&gt; &lt;div class="box" style="width: 100px;"&gt;&lt;/div&gt;&lt;/body&gt; 12// index.css.box &#123; background-color: orange; &#125; 12345//JavaScriptvar box = document.getElementsByClassName('box')[0];console.log(box.style.width);console.log(box.style.height);console.log(box.style.backgroundColor); 得到的测试结果为：123'100px''''' 由以上的结果我们可以得出一个结论：style只能获取行内样式的值，无法获取嵌入式样式和外部样式的值 那么我们怎样才能获取到内嵌样式和外部样式呢？ 解决方法在IE浏览器使用obj.currentStyle.width格式,在FF或Chrome浏览器使用document.defaultView.getComputedStyle(obj,false).width格式 123456789101112// currentStyle: IE下获取元素样式的值if ( box.currentStyle ) &#123; console.log( 'this is IE.' ); console.log( box.currentStyle.width ); console.log( box.currentStyle.height ); console.log( box.currentStyle.backgroundColor );&#125; else &#123; // chorme and firefox console.log( document.defaultView.getComputedStyle(box, false).width ); console.log( document.defaultView.getComputedStyle(box, fasle).height ); console.log( document.defaultView.getComputedStyle(box, false).backgroundColor );&#125; PS:“DOM2级样式”增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如“:after”）。如果不需要伪元素信息，第二个参数可以是null。getComputerStyle()方法返回一个CSSStyleDeclaration对象，其中包含当前元素的所有计算的样式。 其语法为：document.defaultView.getComputedStyle(&#39;元素&#39;, &#39;伪类&#39;)； 综上，我们可以写一个获取元素样式值的方法：(实际上，使用defaultView基本上是没有必要的，getComputedStyle本身就存在window对象之中) 12345678910111213function getStyle(obj,attr,value)&#123; if(!value)&#123; if(obj.currentStyle)&#123; //IE浏览器下 return obj.currentStyle(attr); &#125; else&#123; return obj.getComputedStyle(attr,false); //ff,safari,opera,chrome浏览器下 &#125; &#125; else&#123; obj.style[attr]=value; //修改样式,style属性能写能读 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vuex学习笔记]]></title>
      <url>%2F2017%2F04%2F04%2Fvuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;vuex是vuejs应用程序专门开发的 状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 安装 直接下载/CDN引用基于NPM的CDN链接(最新版本)：https://unpkg.com/vuex下载后需要在vue之后引入： 12&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/path/to/vuex.js&quot;&gt;&lt;/script&gt; NPM npm install vuex –save 在一个模块化的打包系统中，您必须显式地通过 Vue.use()来安装 Vuex： 1234import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex) 自己构建 如果需要使用 dev 分支下的最新版本，可以直接从 GitHub 上克隆代码并自己构建 git clone https://github.com/vuejs/vuex.git node_modules/vuexcd node_modules/vuexnpm installnpm run build 基本概念 每一个 Vuex 应用的核心就是store(仓库),store里面存储着大部分的state(状态)。 Vuex 和单纯的全局对象有以下两点不同: Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的 唯一途径 就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 store 创建store,初始化state对象和一些mutation 123456789101112// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex) const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125; &#125;) 现在，我们可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更： 1234567// count状态store.state.count// 提交mutationstore.commit(&apos;increment&apos;) 核心概念state 每个应用仅包含一个store(单一状态树)，用一个对象包含了全部的应用层级状态。 在vue组件中获取vuex状态从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： 123456789// 创建一个 Counter 组件 const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125; &#125; 每当 store.state.count变化的时候,都会重新求取计算属性，并且触发更新相关联的 DOM。 但是这种模式导致组件依赖的全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。 Vuex 通过 store 选项，提供了一种机制将状态从根组件『注入』到每一个子组件中（需调用Vue.use(Vuex)）： 1234567891011const app = new Vue(&#123; el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。 mapState 辅助函数可以帮助我们生成计算属性，精简代码： 1234567891011121314151617181920// 在单独构建的版本中辅助函数为 Vuex.mapState import &#123; mapState &#125; from &apos;vuex&apos; export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 // 当计算属性名称和state的子节点名称相同时，也可以向mapState传递一个字符串数组 // 如：&apos;count&apos; count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;) &#125; 对象展开运算符mapState函数返回的是一个对象。对象展开运算符可以讲多个对象合并为一个，方便传递最终对象给computed属性 1234567computed: &#123; localComputed () &#123; /* ... */ &#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState(&#123; // ... &#125;)&#125; getters Vuex 允许我们在 store 中定义『getters』（可以认为是 store 的计算属性）。Getters 接受 state 作为其第一个参数： 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Getters 会暴露为store.getters对象: 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;] Getters 也可以接受其他 getters 作为第二个参数： 1234567getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;store.getters.doneTodosCount // -&gt; 1 这样我们就能在任何组件中使用getters了： 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; mapGetters辅助函数mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性：12345678910111213141516import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getters 混入 computed 对象中 ...mapGetters([ // 如果你想将一个 getter 属性另取一个名字，使用对象形式 // 映射 this.doneCount 为 store.getters.doneTodosCount // doneCount: &apos;doneTodosCount&apos; &apos;doneTodosCount&apos;, &apos;anotherGetter&apos;, // ... ]) &#125;&#125; mutations 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 123456789101112const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, // mutations更像是事件注册，无法直接调用mutation handler mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 要唤醒一个 mutation handler，需要以相应的 type 调用 store.commit 方法: 1store.commit(&apos;increment&apos;) 提交荷载可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： 12345678// ... mutations: &#123; increment (state, n) &#123; state.count += n &#125; &#125; store.commit(&apos;increment&apos;, 10) 当荷载为对象时，可以包含多个字段： 12345678910// ... mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125; &#125; store.commit(&apos;increment&apos;, &#123; amount: 10 &#125;) 对象风格的提交方式提交 mutation 的另一种方式是直接使用包含 type 属性的对象： 1234store.commit(&#123; type: &apos;increment&apos;, amount: 10&#125;) 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变： 12345mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; Mutations 需遵守 Vue 的响应规则mutaion需要遵循vue的响应式原则：1.最好提前在你的 store 中初始化好所有所需属性。2.当需要在对象上添加新属性时，你应该： 使用 Vue.set(obj, ‘newProp’, 123), 或者 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符可以这样写：1state.obj = &#123; ...state.obj, newProp: 123 &#125; mutation 必须是同步函数实例： 1234567mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125; 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用 —— 实质上任何在回调函数中进行的的状态的改变都是不可追踪的。 在组件中提交 Mutations可以在组件中使用this.$store.commit(&#39;xxx&#39;) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。 12345678910111213import &#123; mapMutations &#125; from &apos;vuex&apos; export default &#123; // ... methods: &#123; ...mapMutations([ &apos;increment&apos; // 映射 this.increment() 为 this.$store.commit(&apos;increment&apos;) ]), ...mapMutations(&#123; add: &apos;increment&apos; // 映射 this.add() 为 this.$store.commit(&apos;increment&apos;) &#125;) &#125; &#125; actions Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作示例： 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 分发ActionAction 通过 store.dispatch 方法触发： 1store.dispatch(&apos;increment&apos;) 在 action 内部执行异步操作 1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&apos;increment&apos;) &#125;, 1000) &#125;&#125; Actions 支持同样的 载荷方式 和 对象方式 进行分发 在组件中分发 Action在组件中使用 this.$store.dispatch(&#39;xxx&#39;)分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： 12345678910111213import &#123; mapActions &#125; from &apos;vuex&apos; export default &#123; // ... methods: &#123; ...mapActions([ &apos;increment&apos; // 映射 this.increment() 为 this.$store.dispatch(&apos;increment&apos;) ]), ...mapActions(&#123; add: &apos;increment&apos; // 映射 this.add() 为 this.$store.dispatch(&apos;increment&apos;) &#125;) &#125; &#125; 组合 Actions详情参见(https://vuex.vuejs.org/zh-cn/actions.html) modules 详情参见Modules 项目结构 vuex结构需要遵循一些规则： 1.应用层级的状态应该集中到单个 store 对象中。 2.提交 mutation 是更改状态的唯一方法，并且这个过程是同步的 3.异步逻辑都应该封装到 action 里面。 只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation、和 getters 分割到单独的文件Modules。 对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例： 1234567891011121314├── index.html├── main.js├── api│ └── ... # 抽取出API请求├── components│ ├── App.vue│ └── ...└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 参考 Vuex Vuex官方讲解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP协议状态码解释]]></title>
      <url>%2F2017%2F03%2F25%2FHTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81%E8%A7%A3%E9%87%8A%2F</url>
      <content type="text"><![CDATA[一些常见HTTP状态码为： 200 – 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用 常见HTTP状态码大全1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码 代码说明 http状态码 100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 http状态码 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换 2xx （成功） 表示成功处理了请求的状态代码 代码说明 http状态码 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 http状态码 201 （已创建） 请求成功并且服务器创建了新的资源。 http状态码 202 （已接受） 服务器已接受请求，但尚未处理。 http状态码 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 http状态码 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 http状态码 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 http状态码 206 （部分内容） 服务器成功处理了部分 GET 请求 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码说明 http状态码 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 http状态码 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 http状态码 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 http状态码 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 http状态码 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 http状态码 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 http状态码 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码说明 http状态码 400 （错误请求） 服务器不理解请求的语法。 http状态码 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 http状态码 403 （禁止） 服务器拒绝请求。 http状态码 404 （未找到） 服务器找不到请求的网页。 http状态码 405 （方法禁用） 禁用请求中指定的方法。 http状态码 406 （不接受） 无法使用请求的内容特性响应请求的网页。 http状态码 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 http状态码 408 （请求超时） 服务器等候请求时发生超时。 http状态码 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 http状态码 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 http状态码 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 http状态码 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 http状态码 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 http状态码 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 http状态码 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 http状态码 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 http状态码 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码说明 http状态码 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 http状态码 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 http状态码 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 http状态码 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 http状态码 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 http状态码 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue初学笔记]]></title>
      <url>%2F2017%2F03%2F25%2Fvue%E5%88%9D%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;Vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。(持续更新……) 引用 unpkg（推荐）: https://unpkg.com/vue/dist/vue.js , 会保持和 npm 发布的最新的版本一致 cdnjs : https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js $ npm install vue 命令行工具vuejs提供了一个官方命令行工具vue-cli，可用于快速搭建大型单页应用12345678910# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 跳转到项目根目录$ cd my-project# 安装依赖项$ npm install# 运行项目开发版本$ npm run dev 初始化根实例 new Vue会创建一个vue根实例，用el属性指定挂载的dom节点，data管理该实例的状态。 123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;); 展示结果： 1Hello Vue! v- 指令 v-html用于插入html文本语句(不推荐使用，容易导致XSS攻击) 1&lt;div v-html="text"&gt;&lt;/div&gt; 注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 v-bind用于属性修改 1&lt;div v-bind:class="demo"&gt;&lt;/div&gt; v-bind:可简写为:示例： 123456789101112131415161718192021&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src="imageSrc"&gt;&lt;!-- 缩写 --&gt;&lt;img :src="imageSrc"&gt;&lt;!-- with inline string concatenation --&gt;&lt;img :src="'/path/to/images/' + fileName"&gt;&lt;!-- class 绑定 --&gt;&lt;div :class="&#123; red: isRed &#125;"&gt;&lt;/div&gt;&lt;div :class="[classA, classB]"&gt;&lt;/div&gt;&lt;div :class="[classA, &#123; classB: isB, classC: isC &#125;]"&gt;&lt;!-- style 绑定 --&gt;&lt;div :style="&#123; fontSize: size + 'px' &#125;"&gt;&lt;/div&gt;&lt;div :style="[styleObjectA, styleObjectB]"&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind="&#123; id: someProp, 'other-attr': otherProp &#125;"&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop="text"&gt;&lt;/div&gt;&lt;!-- prop 绑定. “prop” 必须在 my-component 中声明。 --&gt;&lt;my-component :prop="someThing"&gt;&lt;/my-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special="foo"&gt;&lt;/a&gt;&lt;/svg&gt; v-on用于监听事件 1&lt;button v-on:click="addSomething"&gt;&lt;/button&gt; v-on:可简写为@在监听原生 DOM 事件时，方法以事件为唯一的参数$event 事件监听可以在event.target后加上修饰符: .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .native - 监听组件根元素的原生事件。 示例： 123456789101112131415161718&lt;!-- 方法处理器 --&gt;&lt;button v-on:click="doThis"&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click="doThat('hello', $event)"&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click="doThis"&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent="doThis"&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter="onEnter"&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;input @keyup.13="onEnter"&gt; v-if 根据表达式的值的真假条件渲染元素在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 &lt;template&gt; ，将提出它的内容作为条件块。 1&lt;template v-if=&quot;boolean&quot;&gt;&lt;/template&gt; v-show 根据表达式之真假值，切换元素的 display CSS 属性带有 v-show 的元素始终会被渲染并保留在 DOM 中 1234&lt;ul&gt; &lt;li v-show="boolean1"&gt;&lt;/li&gt; &lt;li v-show="boolean2"&gt;&lt;/li&gt;&lt;/ul&gt; 注意， v-show 不支持 &lt;template&gt; 语法，也不支持 v-else v-for 基于源数据循环迭代渲染元素或模板块v-for默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素,您需要提供一个 key 的特殊属性: 123456&lt;div v-for="item in items" :key="item.id"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt;&lt;div v-for="(item, index) in items"&gt;&lt;/div&gt;&lt;div v-for="(val, key) in object"&gt;&lt;/div&gt;&lt;div v-for="(val, key, index) in object"&gt;&lt;/div&gt; v-model 在表单控件或者组件上创建双向绑定该指令的绑定元素有限制，只能在表单控件和组件上使用 12&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 以上示例将input的输入与data管理的message绑定，当输入变化时，更新message的值 v-model可以添加特殊的修饰符，实现某些功能： .lazy - 取代 input 监听 change 事件 .number - 输入字符串转为数字 .trim - 输入首尾空格过滤 vue实例生命周期&emsp;&emsp;每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM ，在这个过程中，实例也会调用一些 生命周期钩子，如 mounted、 updated 、destroyed。生命周期图示： 注释： beforeCreate // 该方法在组件尚未创建前触发，此时data数据和节点都尚未渲染，事件和watch监听事件暂未配置 created // 该方法在组件实例已经创建，但是组件尚未挂载到页面中，data数据已产生，节点尚未被渲染出来，watch事件监听和mathods事件配置已挂载到vue中 beforeMount // 该方法组件尚未被挂载到页面中，render函数首次调用 mounted // 该方法在dom节点已经渲染完成后并且节点已经被替换成vue节点绑定，可以在该方法中获取到vue绑定节点 beforeUpdate // 该方法是在数据更新时调用，发生在虚拟dom渲染到vue的html模板上之前触发事件 updated // 该方法是在数据更改，虚拟dom重新渲染和打补丁之后触发该事件， activated // 该事件是在keep-alive组件被激活时调用 deactivated // 该事件是在keep-alive组件停用时调用 beforeDestroy // 该事件是在组件销毁前调用，用户离开组件时调用 destroyed // 该事件是在组件完全销毁后，但是Vue 实例指示的所有东西都尚未解除绑定，该事件触发完成后，所有的事件监听器会被移除，所有的子实例也会被销毁。 响应式组件自定义事件使用v-on绑定自定义事件&emsp;&emsp;每个Vue实例都实现了事件接口： $on(eventName)监听事件 $emit(eventName,enentTarget)触发事件不能用$on侦听子组件抛出的事件，而必须在父组件的子组件模板里直接用v-on绑定 12345&lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt; 12345678910111213141516171819202122232425Vue.component('button-counter', &#123; template: '&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;); .native修饰v-on可在某个组件的根元素上监听一个原生事件 1&lt;my-component v-on:click.native="doTheThing"&gt;&lt;/my-component&gt; 使用自定义事件的表单绑定组件自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定12345&lt;input v-model="something"&gt;// 相当于(语法糖)&lt;input v-bind:value="something" v-on:input="something = $event.target.value"&gt;// 绑定组件简写为&lt;custom-input v-bind:value="something" v-on:input="something = arguments[0]"&gt;&lt;/custom-input&gt; 非父子组件通信两个组件也需要通信(非父子关系)。在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线，示例如下：1var bus = new Vue() 12// 触发组件 A 中的事件bus.$emit(&apos;id-selected&apos;, 1) 1234// 在组件 B 创建的钩子中监听事件bus.$on(&apos;id-selected&apos;, function (id) &#123; // ...&#125;) 在复杂的情况下，我们应该考虑使用专门的状态管理模式,如Vuex. 过渡效果插件vue-routervuex参考 Vuejs官方教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo+github搭建个人博客(绑定域名)]]></title>
      <url>%2F2017%2F03%2F20%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2(%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D)%2F</url>
      <content type="text"><![CDATA[前言&emsp;&emsp;一直想自己搞个人博客，在上面记录一些自己的日常！如今，github提供了免费的域名和空间，用户可以通过username.github.io来设置自己的个人主页或博客，虽然是静态的，但是聊胜于无啊。利用github pages的特性，一开始我使用jekyll来构造整个博客静态网站，但是使用了一阵子发现有不小的局限性以及扩展性不强，于是迁移到了生态圈更大的hexo,套用了简洁美观的next主题。同时将username.github.io挂载在了自己的私人域名下wardlin.site&emsp;&emsp;如今博客大体框架已经搭建好了，具备了首页、个人主页、分类、音乐播放等模板。其他的一些功能如评论、分享等会陆续更新……&emsp;&emsp;如今以这篇日记简单记录一下整个过程，以备后用！ 准备 操作系统：window10 64 bit nodejs v6.10.0 Git v2.9.0 github个人账户 搭建博客框架hexo 安装在安装好nodejs的同时，我们也安装了npm(nodejs的包管理工具)。npm的安装源可以换成淘宝NPM镜像，防止被’墙’。 npm install -g cnpm –registry=https://registry.npm.taobao.org 要想在gitbash中运行node和npm命令，node需要全局安装或者nodejs的path环境变量在系统盘下，如下图： 然后在d盘根目录下创建blog文件夹，右键’Git bash’打开操作界面，输入指令 $ cnpm install -g hexo-cli 再继续输入命令 $ cnpm install hexo –save 输入以下命令初始化blog文件夹结构(详细解读参考hexo建站) $ npm install 成功后输入hexo -v就可以看到对应的版本号了！ 本地运行hexo初始化hexo $ hexo init 运行hexo $ hexo s -g 根据提示，在浏览器输入http://localhost:4000就可以看到博客的模型了 管理博客配置信息_config.yml文件，以下统称站点配置文件 用编辑器打开blog/_config.yml文件，进行个人设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#博客名称title: #副标题subtitle: #简介,方便爬虫爬取博客信息(SEO)description: #博客作者author: username#博客语言(简体中文)language: zh-Hans#时区(默认和电脑的时区一致)timezone:#博客地址,与申请的GitHub一致url: http://username.github.ioroot: /#博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:default_category: uncategorizedcategory_map:tag_map:#日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss#分页，每页文章数量per_page: 10pagination_dir: page#博客主题theme: landscape#发布到github.io库设置deploy: type: git #username改为你的github用户名 repository: https://github.com/username/username.github.io.git branch: master 写博客 $ hexo new ‘hello’ 这会在blog/source/_post文件夹下生成hello.md，打开该文件就可以编辑了。markdown语法 123456789101112title: hellodate: 2015-07-01 22:37:23categories: - 日志 - 二级目录tags: - hello---摘要:&lt;!--more--&gt;正文: 所有的博文都保存在blog/source/_post文件下 本地预览新博文 生成静态文件(blog/public文件夹下) $ hexo generate 命令可简写为hexo g 发表草稿 $ hexo publish [layout] 启动本地服务器 $ hexo server 命令可简写为hexo s 部署网站(这里用于提交博客信息到github上) $ hexo deploy 命令可简写为hexo d 创建github.io库&emsp;&emsp;在自己的github上新建一个repository，命名为uesrname.github.io(username为你的github账号名)。然后在该仓库右边”setting”设置git pages为”Launch automatic page generator”。&emsp;&emsp;在电脑上gitbash窗口使用 hexo d可以提交博客网站文件到github上。 绑定个人域名和github地址 购买私人域名到阿里云上购买一个域名，进行实名认证 github.io库创建CNAME文件到username.github.io仓库根目录下创建CNAME文件(文件名大写，无后缀)，在该文件写上自己需要绑定的域名(不需要添加www),例子： 1wardlin.site 去域名提供商上设置域名解析 到阿里云上找到域名，点击’管理’，进行DNS修改，将DNS服务器修改为f1g1ns1.dnspod.net和f1g1ns2.dnspod.net(dnspod是国内解析，速度更快) 点击’域名解析’，添加解析如下图： 注册登录dnspod官网，同样的添加自己的域名，然后在域名下添加上面的三条解析记录 访问域名访问自己的私人域名，估计设置几分钟之后便能生效(访问username.github.io会跳转到购买的域名下) 使用next主题下载next主题包next主题下的_config.yml(blog/themes/next/_config.yml)文件统称为主题配置文件在gitbash窗口中输入以下命令 $ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点配置文件， 找到theme字段，并将其值更改为next 1theme: next 先用hexo clean清除缓存，再用下列命令验证next主题是否应用成功 $ hexo g$ hexo s 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 选择Scheme Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 这是next主题提供的三种不同外观，我选择的是Mist风格外观在主题配置文件下修改scheme123#scheme: Muse#scheme: Mistscheme: Pisces 设置头像编辑主题配置文件，修改字段avatar，值设置成头像的链接地址。其中，头像的链接地址可以是： 添加「标签」页面新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子： 12345title: 标签测试文章tags: - Testing - Another Tag--- 新建页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ： $ cd your-hexo-site$ hexo new page tags 设置页面编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下： 1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;--- 修改菜单在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中，如下: 1234menu:home: /archives: /archivestags: /tags 详细说明可参考官方文档添加「标签」页面 添加「分类」页面分类页面的添加与标签的方法相同，可参考官方文档添加「分类」页面 添加「音乐」功能 在网页版网易云音乐找到心仪歌曲的外链 点击外链，复制其HTML代码 在theme/layout里找到侧边栏文件sidebar.swig，在endif之前加入上面的HTML代码 添加 社交链接在侧边栏添加社交链接，需要在主题配置文件中设置链接和链接图标 链接链接放置在social字段下，一行一个链接。其键值格式是显示文本: 链接地址 12345678# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 链接图片设定链接的图标，对应的字段是social_icons。其键值格式是匹配键: Font Awesome 图标名称，匹配键与上一步所配置的链接的显示文本 相同（大小写严格匹配），图标名称是 Font Awesome 图标的名字（不必带 fa- 前缀）。enable 选项用于控制是否显示图标，你可以设置成false来去掉图标。 1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 添加「Local Search」页面(简单版) 安装 hexo-generator-searchdb 编辑 站点配置文件，添加以下字段： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 ，启用本地搜索 123# Local searchlocal_search: enable: true 添加「Algolia搜索」页面&emsp;&emsp;另一种搜索服务集成Algolia，因为之前广泛使用的Swiftype 站内搜索官方已经暂停了个人使用，只能通过企业注册使用。当然，Algolia也提供了很好的搜索服务，它是是一家致力于为用户提供毫秒级的数据库搜索服务的法国初创公司，其初衷是致力于让客户可以获得“100ms”等级的实时搜索服务。并且在next主题的5.1以上版本已经集成Algolia站内搜索功能，使用起来很便捷。 注册登录Algolia官网，我使用github账号登录 进入Dashboard的Indices界面，点击NEW INDEX添加关键字INDEX 点击左侧API Keys，可以获取到我们需要的信息(还有上面的INDEX) 安装hexo-algoliasearch插件并填写配置信息 $ npm install hexo-algolia –save 在根目录的站点配置文件中加入如下配置,注意改成前面algolia注册获得的数据 1234567891011search: truealgolia:appId: &apos;appId&apos;apiKey: &apos;apiKey&apos;adminApiKey: &apos;adminApiKey&apos;indexName: &apos;indexName&apos;chunkSize: 5000fields: - title - slug - content:strip 在`主题配置文件``中加入以下配置 12algolia_search: enable: true 接着gitbash窗口执行以下命令，确保数据上传到Algolia成功(不成功可以尝试先清除缓存hexo clean) $ hexo algolia 此时到Algolia官网上查看会有成功上传的网站信息 在theme中添加布局和样式文件 新建algolia.swig(/themes/next/layout/_partials/search/algolia.swig) 123456789101112131415161718192021&lt;div class=&quot;site-search&quot;&gt; &lt;div class=&quot;algolia-popup popup&quot;&gt; &lt;div class=&quot;algolia-search&quot;&gt; &lt;div class=&quot;algolia-search-input-icon&quot;&gt; &lt;i class=&quot;fa fa-search&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;algolia-search-input&quot; id=&quot;algolia-search-input&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;algolia-results&quot;&gt; &lt;div id=&quot;algolia-stats&quot;&gt;&lt;/div&gt; &lt;div id=&quot;algolia-hits&quot;&gt;&lt;/div&gt; &lt;div id=&quot;algolia-pagination&quot; class=&quot;algolia-pagination&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;span class=&quot;popup-btn-close&quot;&gt; &lt;i class=&quot;fa fa-times-circle&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;//cdn.bootcss.com/instantsearch.js/1.7.1/instantsearch.min.js&quot;&gt;&lt;/script&gt; 在search.swig(/themes/next/layout/_partials/search.swig)引入algolia.swig 12&#123;% elseif theme.algolia_search %&#125; &#123;% include &apos;search/algolia.swig&apos; %&#125; 在要触发搜索的HTML节点(/themes/next/layout/_partials/header.swig)加入一个CLASS名为popup-trigger(在line 56之后) 12345678&#123;% elseif config.search %&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;popup-trigger&quot;&gt;&#123;% elseif config.search || theme.algolia_search.enable %&#125; &lt;a href=&quot;javascript:;&quot; class=&quot;popup-trigger&quot;&gt;&#123;% elseif theme.algolia_search %&#125; &lt;a href=&quot;#&quot; class=&quot;popup-trigger&quot;&gt; &#123;&#123; __(&apos;menu.search&apos;) &#125;&#125; &lt;/a&gt; 修改algolia-search.js文件(/themes/next/source/js/src/algolia-search.js)，加入CONFIG对象 12345678910 var CONFIG = &#123; root: &apos;/&apos;, algolia: &#123; applicationID: &apos;applicationID&apos;, apiKey: &apos;apiKey&apos;, indexName: &apos;indexName&apos;, hits: &#123; &quot;per_page&quot;: 10 &#125;, labels: &#123; &quot;input_placeholder&quot;: &quot;Searching...&quot;, &quot;hits_empty&quot;: &quot;未发现与 「$&#123;query&#125;」相关的内容&quot;, &quot;hits_stats&quot;: &quot;$&#123;hits&#125; 条相关条目，使用了 $&#123;time&#125; 毫秒&quot; &#125; &#125;&#125;; 新建search.css(/themes/next/source/css/search.css)样式文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219ul.search-result-list &#123; padding-left: 0px; margin: 0px 5px 0px 8px;&#125;p.search-result &#123; border-bottom: 1px dashed #ccc; padding: 5px 0;&#125;a.search-result-title &#123; font-weight: bold;&#125;a.search-result &#123; border-bottom: transparent; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.search-keyword &#123; border-bottom: 1px dashed #4088b8; font-weight: bold;&#125;#local-search-result &#123; height: 90%; overflow: auto;&#125;.popup &#123; display: none; position: fixed; top: 10%; left: 50%; width: 700px; height: 80%; margin-left: -350px; padding: 3px 0 0 10px; background: #fff; color: #333; z-index: 9999; border-radius: 0px;&#125;@media (max-width: 767px) &#123; .popup &#123; padding: 3px; top: 0; left: 0; margin: 0; width: 100%; height: 100%; border-radius: 0px; &#125;&#125;.popoverlay &#123; display: none; position: fixed; width: 100%; height: 100%; top: 0px; left: 0px; z-index: 2080; background-color: rgba(0,0,0,0.3);&#125;#local-search-input &#123; margin-bottom: 10px; width: 50%;&#125;.popup-btn-close &#123; position: absolute; top: 6px; right: 14px; color: #4ebd79; font-size: 14px; font-weight: bold; text-transform: uppercase; cursor: pointer;&#125;#no-result &#123; position: absolute; left: 44%; top: 42%; color: #ccc;&#125;.busuanzi-count:before &#123; content: &quot; &quot;; float: left; width: 260px; min-height: 25px;&#125;@media (min-width: 768px) and (max-width: 991px) &#123; .busuanzi-count &#123; width: auto; &#125; .busuanzi-count:before &#123; display: none; &#125;&#125;@media (max-width: 767px) &#123; .busuanzi-count &#123; width: auto; &#125; .busuanzi-count:before &#123; display: none; &#125;&#125;.site-uv,.site-pv,.page-pv &#123; display: inline-block;&#125;.site-uv .busuanzi-value,.site-pv .busuanzi-value,.page-pv .busuanzi-value &#123; margin: 0 5px;&#125;.site-uv &#123; margin-right: 10px;&#125;.site-uv::after &#123; content: &quot;|&quot;; padding-left: 10px;&#125;.algolia-popup &#123; overflow: hidden; padding: 0;&#125;.algolia-popup .popup-btn-close &#123; padding-left: 15px; border-left: 1px solid #eee; top: 10px;&#125;.algolia-popup .popup-btn-close .fa &#123; color: #999; font-size: 18px;&#125;.algolia-popup .popup-btn-close:hover .fa &#123; color: #222;&#125;.algolia-search &#123; padding: 10px 15px 5px; max-height: 50px; background: #f5f5f5; border-top-left-radius: 5px; border-top-right-radius: 5px;&#125;.algolia-search-input-icon &#123; display: inline-block; width: 20px;&#125;.algolia-search-input-icon .fa &#123; font-size: 18px;&#125;.algolia-search-input &#123; display: inline-block; width: calc(90% - 20px);&#125;.algolia-search-input input &#123; padding: 5px 0; width: 100%; outline: none; border: none; background: transparent;&#125;.algolia-powered &#123; float: right;&#125;.algolia-powered img &#123; display: inline-block; height: 18px; vertical-align: middle;&#125;.algolia-results &#123; position: relative; overflow: auto; padding: 10px 30px; height: calc(100% - 50px);&#125;.algolia-results hr &#123; margin: 10px 0;&#125;.algolia-results .highlight &#123; font-style: normal; margin: 0; padding: 0 2px; font-size: inherit; color: #f00;&#125;.algolia-hits &#123; margin-top: 20px;&#125;.algolia-hit-item &#123; margin: 15px 0;&#125;.algolia-hit-item-link &#123; display: block; border-bottom: 1px dashed #ccc; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.algolia-pagination .pagination &#123; margin-top: 40px; border-top: none; padding: 0; text-align: center;&#125;.algolia-pagination .pagination-item &#123; display: inline-block;&#125;.algolia-pagination .page-number &#123; border-top: none;&#125;.algolia-pagination .page-number:hover &#123; border-bottom: 1px solid #222;&#125;.algolia-pagination .disabled-item &#123; visibility: hidden;&#125;.fa-search::before&#123; color: #999999;&#125; 将上述algolia-search.js和search.css文件引入footer.swig文件(/themes/next/layout/_partials/footer.swig) 12&lt;link href=&quot;&#123;&#123; url_for(theme.css) &#125;&#125;/search.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/src/algolia-search.js&quot;&gt;&lt;/script&gt; 此时重新生成静态文件在本地服务器运行，打开浏览器就可以看到想要的效果了 后记:&emsp;&emsp;此时我们点击搜索出来的条目，链接却是undefined。这时我们就需要查看algolia-search.js文件，其中标示了 但是查阅Algolia官网的JSON ANSWER，并不包含permalink和path字段 所以链接的值为undefined 解决方法: algolia-search.js修改link参数如下 1var link = data.permalink ? data.permalink : data.slug; 站点配置文件修改permalink的格式为 1permalink: :title/ 参考 零基础免费搭建个人博客-hexo+github hexo文档 NexT 使用文档 在github上搭建自己的主页和域名的绑定 Hexo+Next主题集成Algolia搜索]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在标签页头部插入个性图标]]></title>
      <url>%2F2017%2F03%2F18%2F%E5%9C%A8%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5%E4%B8%AA%E6%80%A7%E5%9B%BE%E6%A0%87%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;在建立自己的个人网站时，我们都希望能够让自己的网站更个人化或者辨识度更高，那么在个人网站的标签页头部显示自己的logo便是一种很好的方法！ 浏览器通用方法 把favicon.ico图标放到网站根目录下，在网页的&lt;head&gt;&lt;/head&gt;中加入 1&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon" /&gt; IE或TT浏览器 把需要显示的16x16像素的ICO图标命名为favicon.ico放置在网站根目录下，浏览器会自动检索 Firefox浏览器 图标格式没有IE那么严格，GIF和PNG格式的图标也可以显示，图标名称也可以不是favcion 把图标放在根目录后，在&lt;head&gt;&lt;/head&gt;中加入 12&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon" /&gt;&lt;link rel="icon" href="gif_favicon.gif" type="image/gif" &gt; 或 12&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon" /&gt;&lt;link rel="icon" href="png_favicon.png" type=" image/png" &gt; 实际上现在只要在网站根目录下放置一个faviocn.ico，浏览器都能识别了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何将本地仓库的新版本推送到github上]]></title>
      <url>%2F2017%2F02%2F15%2F%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC%E6%8E%A8%E9%80%81%E5%88%B0github%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;本文主要介绍本地master分支推送更新到github上的基本命令和流程 git基本流程 1.在github上创建一个空项目； 2.通过git clone 获取github项目 先复制下项目的地址 命令行:git clone 项目地址 3.可以本地的项目里编写代码,创建文件了 4.提交编辑的文件到git暂存区 命令行:git add . 5.提交暂存区的文件到本地git 命令行:git commit -m &quot;提交说明&quot; 6.提交本地git到远程服务器 github 命令行:git push origin master 输入账号密码 PS：每次执行完命令行应该都看下执行状态 命令行:git status 第一次提交项目到远程服务器的时候可以需要配置用户名和邮箱 不提示就不需要配置 命令行：git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot; git基本操作命令行图 参考 版本控制工具Git 常用操作命令 Pro Git（中文版）]]></content>
    </entry>

    
  
  
</search>
